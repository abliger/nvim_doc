<!DOCTYPE html>
<html lang="en">

<head>
   <meta charset="utf-8">
   <meta content="IE=edge" http-equiv="X-UA-Compatible">
   <meta name="description" content="vim out of the box">
   <meta content="width=device-width, initial-scale=1" name="viewport">
   <title>Nvim 文档: usr_10</title>
   <link href="https://fonts.googleapis.com/css?family=Lato:400,700,900" rel="stylesheet">
   <link href="../css/normalize.min.css" rel="stylesheet">
   <link href="../css/bootstrap.css" rel="stylesheet">
   <link href="../css/main.css" rel="stylesheet">
   <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
      <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

</head>

<body>
   <header class="container">
      <nav class="navbar navbar-expand-lg">
         <div class="container-fluid">
            <a href="/" class="navbar-brand" aria-label="logo">
               <svg xmlns="http://www.w3.org/2000/svg" role="img" width="173" height="50" viewBox="0 0 742 214"
                  aria-label="Neovim">
                  <title>Neovim</title>
                  <defs>
                     <linearGradient x1="50%" y1="0%" x2="50%" y2="100%" id="a">
                        <stop stop-color="#16B0ED" stop-opacity=".8" offset="0%" />
                        <stop stop-color="#0F59B2" stop-opacity=".837" offset="100%" />
                     </linearGradient>
                     <linearGradient x1="50%" y1="0%" x2="50%" y2="100%" id="b">
                        <stop stop-color="#7DB643" offset="0%" />
                        <stop stop-color="#367533" offset="100%" />
                     </linearGradient>
                     <linearGradient x1="50%" y1="0%" x2="50%" y2="100%" id="c">
                        <stop stop-color="#88C649" stop-opacity=".8" offset="0%" />
                        <stop stop-color="#439240" stop-opacity=".84" offset="100%" />
                     </linearGradient>
                  </defs>
                  <g fill="none" fill-rule="evenodd">
                     <path d="M.027 45.459L45.224-.173v212.171L.027 166.894V45.459z" fill="url(#a)"
                        transform="translate(1 1)" />
                     <path d="M129.337 45.89L175.152-.149l-.928 212.146-45.197-45.104.31-121.005z" fill="url(#b)"
                        transform="matrix(-1 0 0 1 305 1)" />
                     <path d="M45.194-.137L162.7 179.173l-32.882 32.881L12.25 33.141 45.194-.137z" fill="url(#c)"
                        transform="translate(1 1)" />
                     <path d="M46.234 84.032l-.063 7.063-36.28-53.563 3.36-3.422 32.983 49.922z" fill-opacity=".13"
                        fill="#000" />
                     <g fill="#444">
                        <path
                           d="M227 154V64.44h4.655c1.55 0 2.445.75 2.685 2.25l.806 13.502c4.058-5.16 8.786-9.316 14.188-12.466 5.4-3.15 11.413-4.726 18.037-4.726 4.893 0 9.205.781 12.935 2.34 3.729 1.561 6.817 3.811 9.264 6.751 2.448 2.942 4.297 6.48 5.55 10.621 1.253 4.14 1.88 8.821 1.88 14.042V154h-8.504V96.754c0-8.402-1.91-14.987-5.729-19.757-3.82-4.771-9.667-7.156-17.544-7.156-5.851 0-11.28 1.516-16.292 4.545-5.013 3.032-9.489 7.187-13.427 12.467V154H227zM350.624 63c5.066 0 9.755.868 14.069 2.605 4.312 1.738 8.052 4.268 11.219 7.592s5.638 7.412 7.419 12.264C385.11 90.313 386 95.883 386 102.17c0 1.318-.195 2.216-.588 2.696-.393.48-1.01.719-1.851.719h-64.966v1.70c0 6.708.784 12.609 2.353 17.7 1.567 5.09 3.8 9.357 6.695 12.802 2.895 3.445 6.393 6.034 10.495 7.771 4.1 1.738 8.686 2.606 13.752 2.606 4.524 0 8.446-.494 11.762-1.483 3.317-.988 6.108-2.097 8.37-3.324 2.261-1.227 4.056-2.336 5.383-3.324 1.326-.988 2.292-1.482 2.895-1.482.784 0 1.388.3 1.81.898l2.352 2.875c-1.448 1.797-3.362 3.475-5.745 5.031-2.383 1.558-5.038 2.891-7.962 3.998-2.926 1.109-6.062 1.991-9.41 2.65a52.21 52.21 0 01-10.088.989c-6.152 0-11.762-1.064-16.828-3.19-5.067-2.125-9.415-5.225-13.043-9.298-3.63-4.074-6.435-9.06-8.415-14.96C310.99 121.655 310 114.9 310 107.294c0-6.408.92-12.323 2.76-17.744 1.84-5.421 4.493-10.093 7.961-14.016 3.467-3.922 7.72-6.991 12.758-9.209C338.513 64.11 344.229 63 350.624 63zm.573 6c-4.696 0-8.904.702-12.623 2.105-3.721 1.404-6.936 3.421-9.65 6.053-2.713 2.631-4.908 5.79-6.586 9.474S319.55 94.439 319 99h60c0-4.679-.672-8.874-2.013-12.588-1.343-3.712-3.232-6.856-5.67-9.43-2.44-2.571-5.367-4.545-8.782-5.92-3.413-1.374-7.192-2.062-11.338-2.062zM435.546 63c6.526 0 12.368 1.093 17.524 3.28 5.154 2.186 9.5 5.286 13.04 9.298 3.538 4.013 6.238 8.85 8.099 14.51 1.861 5.66 2.791 11.994 2.791 19.002 0 7.008-.932 13.327-2.791 18.957-1.861 5.631-4.561 10.452-8.099 14.465-3.54 4.012-7.886 7.097-13.04 9.254-5.156 2.156-10.998 3.234-17.524 3.234-6.529 0-12.369-1.078-17.525-3.234-5.155-2.157-9.517-5.242-13.085-9.254-3.57-4.013-6.285-8.836-8.145-14.465-1.861-5.63-2.791-11.95-2.791-18.957 0-7.008.93-13.342 2.791-19.002 1.861-5.66 4.576-10.496 8.145-14.51 3.568-4.012 7.93-7.112 13.085-9.299C423.177 64.094 429.017 63 435.546 63zm-.501 86c5.341 0 10.006-.918 13.997-2.757 3.99-1.838 7.32-4.474 9.992-7.909 2.67-3.435 4.664-7.576 5.986-12.428 1.317-4.85 1.98-10.288 1.98-16.316 0-5.965-.66-11.389-1.98-16.27-1.322-4.88-3.316-9.053-5.986-12.519-2.67-3.463-6-6.13-9.992-7.999-3.991-1.867-8.657-2.802-13.997-2.802s-10.008.935-13.997 2.802c-3.991 1.87-7.322 4.536-9.992 8-2.671 3.465-4.68 7.637-6.03 12.518-1.35 4.881-2.026 10.305-2.026 16.27 0 6.026.675 11.465 2.025 16.316 1.35 4.852 3.36 8.993 6.031 12.428 2.67 3.435 6 6.07 9.992 7.91 3.99 1.838 8.656 2.756 13.997 2.756z"
                           fill="currentColor" />
                        <path
                           d="M530.57 152h-20.05L474 60h18.35c1.61 0 2.967.39 4.072 1.166 1.103.778 1.865 1.763 2.283 2.959l17.722 49.138a92.762 92.762 0 012.551 8.429c.686 2.751 1.298 5.5 1.835 8.25.537-2.75 1.148-5.499 1.835-8.25a77.713 77.713 0 012.64-8.429l18.171-49.138c.417-1.196 1.164-2.181 2.238-2.96 1.074-.776 2.356-1.165 3.849-1.165H567l-36.43 92zM572 61h23v92h-23zM610 153V60.443h13.624c2.887 0 4.78 1.354 5.682 4.06l1.443 6.856a52.7 52.7 0 015.097-4.962 32.732 32.732 0 015.683-3.879 30.731 30.731 0 016.496-2.57c2.314-.632 4.855-.948 7.624-.948 5.832 0 10.63 1.579 14.39 4.736 3.758 3.157 6.57 7.352 8.434 12.585 1.444-3.068 3.248-5.698 5.413-7.894 2.165-2.194 4.541-3.984 7.127-5.367a32.848 32.848 0 018.254-3.068 39.597 39.597 0 018.796-.992c5.111 0 9.653.783 13.622 2.345 3.97 1.565 7.307 3.849 10.014 6.857 2.706 3.007 4.766 6.675 6.18 11.005C739.29 83.537 740 88.5 740 94.092V153h-22.284V94.092c0-5.894-1.294-10.329-3.878-13.306-2.587-2.977-6.376-4.465-11.368-4.465-2.286 0-4.404.391-6.358 1.172a15.189 15.189 0 00-5.144 3.383c-1.473 1.474-2.631 3.324-3.474 5.548-.842 2.225-1.263 4.781-1.263 7.668V153h-22.37V94.092c0-6.194-1.249-10.704-3.744-13.532-2.497-2.825-6.18-4.24-11.051-4.24-3.19 0-6.18.798-8.976 2.391-2.799 1.593-5.399 3.775-7.804 6.54V153H610zM572 30h23v19h-23z"
                           fill="currentColor" fill-opacity=".8" />
                     </g>
                  </g>
               </svg>
            </a>
         </div>
      </nav>
   </header>

   <div class="container">
      <h1>Nvim 文档: usr_10</h1>
      <A NAME="top"></A>
      <A HREF="index\.html">主帮助文件</A>

      <HR>
      <PRE>

*<A NAME="usr_10.txt"></A><B>usr_10.txt</B>*	Nvim

		     VIM用户手册 - by Bram Moolenaar

			     做大改变


在第四章节，介绍了一些方法去做小改变.在这个章节我们做替换或者大段地改变.<A HREF="visual\.html#Visual">可视</A>模式允许使用文本块选中不同的文本.使用扩展程序去做真正复杂的事情.

|<A HREF="#10.1">10.1</A>|	记录和回退命令
|<A HREF="#10.2">10.2</A>|	替换
|<A HREF="#10.3">10.3</A>|	命令范围
|<A HREF="#10.4">10.4</A>|	全局命令
|<A HREF="#10.5">10.5</A>|	<A HREF="visual.html#Visual">可视</A> 块模式
|<A HREF="#10.6">10.6</A>|	读<A HREF="editing.html#writing">写</A>文件内容
|<A HREF="#10.7">10.7</A>|	格式化文本
|<A HREF="#10.8">10.8</A>|	改变<A HREF="change.html#case">大小写</A>
|<A HREF="#10.9">10.9</A>|	使用扩展程序

下一章: |<A HREF="usr_11.html">usr_11.txt</A>|  从崩溃中恢复
上一章: |<A HREF="usr_09.html">usr_09.txt</A>|  使用<A HREF="gui\.html#GUI">GUI</A>
目录:   |<A HREF="usr_toc.html">usr_toc.txt</A>|

==============================================================================

*<A NAME="10.1"></A><B>10.1</B>*	记录和回退命令

&quot;<A HREF="repeat.html#.">.</A>&quot;命令重复之前的改变.但是你怎样做复杂改变而不是单次变化?这就应当使用<A HREF="repeat.html#recording">记录</A>命令了.有三个步骤:

1. &quot;q{register}&quot;命令开始<A HREF="repeat.html#recording">记录</A>按键到名为<A HREF="change.html#{register}">{register}</A>的<A HREF="intro.html#register">寄存器</A>中.<A HREF="intro.html#register">寄存器</A>名字必须在 a 到<A HREF="scroll.html#z.">z之间.</A>
2. 输入你的命令.
3. 结束<A HREF="repeat.html#recording">记录</A>使用<A HREF="repeat.html#q">q</A> (不需要其他字符).

现在你可以键入&quot;@{register}&quot;执行<A HREF="map.html#macro">宏指令</A>.

现在看看你可以怎么用这些命令。假设你有如下文件名列表:

<B><FONT color="#3A6F2B">	stdio.h </FONT></B>
<B><FONT color="#3A6F2B">	fcntl.h </FONT></B>
<B><FONT color="#3A6F2B">	unistd.h </FONT></B>
<B><FONT color="#3A6F2B">	stdlib.h </FONT></B>

你想要下面这样:

<B><FONT color="#3A6F2B">	#include "stdio.h" </FONT></B>
<B><FONT color="#3A6F2B">	#include "fcntl.h" </FONT></B>
<B><FONT color="#3A6F2B">	#include "unistd.h" </FONT></B>
<B><FONT color="#3A6F2B">	#include "stdlib.h" </FONT></B>

你要移动光标到第一行的行首并执行下面的命令:

	qa			开始<A HREF="repeat.html#recording">记录</A>一个<A HREF="map.html#macro">宏指令</A>到<A HREF="intro.html#register">寄存器</A> a中.
	^			移动到行首
	i#include &quot;<A HREF="intro.html#&lt;Esc&gt;">&lt;Esc&gt;</A>	在行首<A HREF="insert.html#Insert">插入</A><A HREF="options\.html#options">字符串</A> #include &quot;.
	$			移动到行尾.
	a&quot;&lt;Esc&gt;			添加双引号(&quot;)到行尾.
	<A HREF="motion.html#j">j</A>			到下一行.
	<A HREF="repeat.html#q">q</A>			停止<A HREF="repeat.html#recording">记录</A><A HREF="map.html#macro">宏指令</A>.

现在你能运行它了, 你能加入&quot;@a&quot;三次去重复改变.
   &quot;@a&quot;命令能添加<A HREF="intro.html#count">数字</A>前缀,代表<A HREF="map.html#macro">宏指令</A>执行次数.本例中你能输入:

<B>	3@a</B>


移动和执行

你可能有很多行想要修改.只需要把光标移动到相应位置然后执行&quot;@a&quot;命令.如果你已执行一次,你可以使用&quot;<A HREF="repeat.html#@@">@@</A>&quot;再次执行. 这个键入会容易一些.如果你现在执行<A HREF="intro.html#register">寄存器</A><A HREF="motion.html#b">b</A>的命令 &quot;@b&quot;, 那么&quot;<A HREF="repeat.html#@@">@@</A>&quot;会使用<A HREF="intro.html#register">寄存器</A> <A HREF="motion.html#b">b</A>.
   如果你比较回放命令和&quot;<A HREF="repeat.html#.">.</A>&quot;,有以下不同.首先, &quot;<A HREF="repeat.html#.">.</A>&quot;只能重复一次.上例中&quot;@a&quot;可以回放多个改变且能移动.
   第二, &quot;<A HREF="repeat.html#.">.</A>&quot;只能记住最后一次改变. 使用<A HREF="intro.html#register">寄存器</A>允许你在很多次变化后，依然能执行&quot;@a&quot;.  
   最后, 你能使用26种不同的<A HREF="change.html#registers">寄存器</A>.因此，你可以记录多达 26 个命令序列.


使用寄存器

用来记录操作的寄存器与你用来拷贝删除文本的寄存器是相同的。这允许你混合记录操作和其它命令来操作这些寄存器。假设你在寄存器 n 中记录了一些命令。当你通过 "@n" 执行这些命令时，你发现这些命令有些问题。这时你可以重新录一次，但这样你可能还会犯其它错误。其实，你可以使用如下窍门:

	<A HREF="motion.html#G">G</A>			到文件结尾.
	o&lt;Esc&gt;			创建空白行.
	&quot;np       黏贴 n 寄存器中的文本，你的命令将被黏贴到整个文件的结尾.
	{edits}			修改错误的命令，就行编辑文字一样.
	0			移动到行首.
	&quot;ny$	把正确的命令拷贝回 n 寄存器.
	<A HREF="change.html#dd">dd</A>			删除临时行.

现在你能使用&quot;@n&quot;执行正确的命令了.  (如果你记录的命令包括换行符，请调整上面例子中最后两行的操作来包括所有的行.)


添加寄存器

到此为止，我们一直使用小写的寄存器名。要附加命令到一个寄存器中，可以使用大写的寄存器名。
假设你在寄存器 c 中已经记录了一个修改一个单词的命令。它可以正常工作，但现在你需要附加一个搜索命令以便找到下一个单词来修改。这可以通过如下命令来完成:

<B>	qC/word&lt;Enter&gt;q</B>

启动 "qC" 命令可以对 c 寄存器追加记录。由此可见，记录到一个大写寄存器表示附加命令到对应的小写寄存器。

这种方法在宏记录，拷贝和删除命令中都有效。例如，你需要把选择一些行到一个寄存器中，可以先这样拷贝第一行:

<B>	"ayy</B>

然后移到下一个要拷贝的地方，执行:

<B>	"Ayy</B>

如此类推。这样在寄存器 a 中就会包括所有你要拷贝的所有行.

==============================================================================

*<A NAME="10.2"></A><B>10.2</B>*	替换						*<A NAME="find-replace"></A><B>find-replace</B>*

&quot;<A HREF="change.html#:substitute">:substitute</A>&quot;命令能让你在整行执行<A HREF="options\.html#options">字符串</A>替换.下面是这个命令的一般形式:

<B>	:[range]substitute/from/to/[flags]</B>

这个命令使行中<A HREF="cmdline.html#[range]">[range]</A>范围内找到the &quot;from&quot; <A HREF="options\.html#options">字符串</A>后改变为&quot;to&quot; <A HREF="options\.html#options">字符串</A>.例如, 你可以使&quot;Professor&quot; 改为 &quot;Teacher&quot;:

<B>	:%substitute/Professor/Teacher/</B>
   注意：
   很少人会把整个 ":substitute" 命令完整敲下来。通常，使用命令的缩写形式
   ":s" 就行了。下文我们将使用这个缩写形式。

命令前面的 "%" 表示命令作用于全部行。如果不指定行范围，":s" 命令只作用在当前行
上。 |<A HREF="#10.3">10.3</A>| 将对 "行范围" 作深入的介绍。

默认情况下，&quot;<A HREF="change.html#:substitute">:substitute</A>&quot; 命令只对某一行中的第一个匹配点起作用。例如，前面例子中会把行:

<B><FONT color="#3A6F2B">	Professor Smith criticized Professor Johnson today. </FONT></B>

改为:

<B><FONT color="#3A6F2B">	Teacher Smith criticized Professor Johnson today. </FONT></B>

要对行中所有匹配点起作用，你需要加一个 g (global，全局) 标记。下面命令:

<B>	:%s/Professor/Teacher/g</B>

结果是 (starting with the original line):

<B><FONT color="#3A6F2B">	Teacher Smith criticized Teacher Johnson today. </FONT></B>

":s" 命令还支持其它一些标志位，包括 "p" (print，打印)，用于在命令执行的时候打印出最后一个被修改的行。还有 "c" (confirm，确认) 标记会在每次替换前向你询问是否需要替换。执行如下命令:

<B>	:%s/Professor/Teacher/c</B>

Vim 找到第一个匹配点的时候会向你提示如下:

<B>	replace with Teacher (y/n/a/q/l/^E/^Y)?</B>

这种时候，你可以输入如下回答中的一个:

	<A HREF="change.html#y">y</A>		Yes;确认改变
	<A HREF="pattern.html#n">n</A>		No; 跳过此匹配.
	a		All;对剩下的匹配点全部执行替换，不需要再确认.
	<A HREF="repeat.html#q">q</A>		Quit; 不再改变.
	<A HREF="motion.html#l">l</A>		Last; 做出改变后退出.
	<A HREF="scroll.html#CTRL-E">CTRL-E</A>		向上滚动一行.
	<A HREF="scroll.html#CTRL-Y">CTRL-Y</A>		向下滚动一行.


":s" 命令中的 "from" 部分实际上是一个 "匹配模式" (还记得吗？这是我们前面给pattern 起的名字译者)，这与查找命令一样。例如， 要替换行首的 "the" 可以这样写:

<B>	:s/^the/these/</B>

如果你要在 "from" 或者 "to" 中使用正斜杠，你需要在前面加上一个反斜杠。更简单的方法是用加号代替正斜杠。例如:

<B>	:s+one/two+one or two+</B>

==============================================================================

*<A NAME="10.3"></A><B>10.3</B>*	命令范围

&quot;<A HREF="change.html#:substitute">:substitute</A>&quot;命令和很多其他的冒号命令可以作用于选中的行.它叫做范围.
   最简单的范围是{number},{number}.例如:

<B>	:1,5s/this/that/g</B>

在1 到 5 行执行替换命令.包括第五行.范围总是放在命令前面.

单个数字表示某个特定行:

<B>	:54s/President/Fool/</B>

当你没有指出一个范围一些命令会作用整个文件.  作用于当前行使用&quot;<A HREF="repeat.html#.">.</A>&quot;符号.&quot;<A HREF="editing.html#:write">:write</A>&quot;命令就是这样.没有范围, <A HREF="motion.html#it">它</A>保存整个文件.使<A HREF="motion.html#it">它</A>保存当前行到文件:

<B>	:.write otherfile</B>

首行数字总是1，但是行尾数字是不确定的.&quot;<A HREF="motion.html#$">$</A>&quot;解决此问题.例如,替换从光标到结尾的内容:

<B>	:.,$s/yes/no/</B>

我们前面使用的&quot;<A HREF="motion.html#&#37;">&#37;</A>&quot;范围实际上是&quot;1,$&quot;的缩写，表示从文件首到文件末.


在范围使用表达式

假设你编辑<A HREF="intro.html#book">书</A>中的一章节,想要使用&quot;gray&quot;替换所有的出现的&quot;grey&quot;.但是现在你只想编辑这一章节而不是其他章节.你知道只有此章节开头有<A HREF="motion.html#word">单词</A> &quot;Chapter&quot;.下面的命令对你有帮助:

<B>	:?^Chapter?,/^Chapter/s=grey=gray=g</B>

你能看到搜索<A HREF="pattern.html#pattern">表达式</A>被使用两次.第一个是 "?^Chapter?"，用于查找前一个行首的"Chapter"，就是说 "?pattern?" 用于向前查找。同样，"/^Chapter/" 用于向后查找下一章。
为了避免斜杠使用的混淆，在这种情况下，"=" 字符用于代替斜杠。使用斜杠或使用其它字符其实也是可以的.


加减号

上面的方案其实还是有问题的: 如果下一章的标题行中包括 "grey"，这个 "grey" 也会被替换掉。如果你正好想这样就最好，可是正好你不想呢？这个时候你需要指定一个偏移。
要查找一个表达式，并且使用它的前一行，需要这样:

<B>	/Chapter/-1</B>

你可以用任意数值代替命令中的 1。要定位匹配点下的第二行，要这样:

<B>	/Chapter/+2</B>

偏移还可以用于其它范围指定符。看一下下面这个例子:

<B>	:.+3,$-5</B>

这指定当前行下面第三行到文件末倒数第五行的范围.


使用标记

除了指定行号，(这需要记住并把它敲出来)，你还可以使用标记。在前面的例子中，你可以用标记指出第三章的位置。例如，用 "mt" 标记开头，再用
"mb" 标记结尾。然后你就可以用标记表示一个范围 (包括标记的那一行):

<B>	:'t,'b</B>


可视模式和范围

你可以使用<A HREF="visual\.html#Visual">可视</A>模式选择文本.然后使用&quot;<A HREF="cmdline.html#:">:</A>&quot;启动冒号命令，将会看到:

<B>	:'&lt;,'&gt;</B>

现在，你可以输入剩下的命令，这个命令的作用范围就是可视模式中指定的范围.

	注意:
   如果使用可视模式选中行的一部分，或者用 CTRL-V 选中一个文本列块，然后执行冒号命令，命令仍作用于整行，而不只是选中的范围。这可能会在以后的版本中修正.

'< 和 '> 实际上是标记，分别标识可视模式的开始和结尾。这个标记一直有效，直到选中了其它的范围为止。你还可以用标记跳转命令 "' <" 跳转到选中文本的开始处。你还可 以把这个标记和其它标记混合，例如:

<B>	:'&gt;,$</B>

这表示从选中部分的结尾到文件末.


行号

如果你知道要修改多少行，你可以先输入一个数值再输入冒号。例如，如果你输入"5:"，你会得到:

<B>	:.,.+4</B>

现在你可以继续你的命令，这个命令将作用于当前行及其后 4 行.

==============================================================================

*<A NAME="10.4"></A><B>10.4</B>*	全局命令

&quot;<A HREF="repeat.html#:global">:global</A>&quot;命令是Vim最强大的命令之一.它允许你发现一个匹配<A HREF="pattern.html#pattern">表达式</A>并在那里执行命令，一般为:

<B>	:[range]global/{pattern}/{command}</B>

和&quot;<A HREF="change.html#:substitute">替换</A>&quot;命令相似.但是它不替代匹配的文本而是执行命令.

注意:
global 中执行的命令只能是冒号命令。普通模式命令不能在这里使用。如果需要，可以使用 |<A HREF="various.html#:normal">:normal</A>| 命令。

假设你要把 "foobar" 修改为 "barfoo"，但只需要修改 C++ 风格的注释中的内容。这种注释以 "//" 开头。所以可以使用如下命令

<B>	:g+//+s/foobar/barfoo/g</B>

这个命令用 ":g" 开头，这是 ":global" 的缩写形式，就像 ":s" 是 ":substitute" 的缩写形式一样。然后是一个匹配模式，由于模式中包括正斜杠，我们用加号作分隔符，后面是一个把 "foobar" 替换成 "barfoo" 的替换命令。全局命令的默认范围是整个文件，所以这个例子中没有指定范围。这一点与":substitute" 是不同的。后者只作用于一行。
这个命令并非完美。因为 "//" 可能出现在一行的中间，但替换命令会把前后的匹配点都替换了。

像 ":substitute" 一样，这里也可以使用各种各样的匹配模式。当你从后面的章节中学会更多的关于模式的知识，它们都可以用在这里.

==============================================================================

*<A NAME="10.5"></A><B>10.5</B>*	<A HREF="visual.html#Visual">可视</A> 块模式

CTRL-V 命令可以选中一个矩形文本块。有几个命令是专门用来处理这个文本块的。

在可视列块模式中，"$" 命令有些特别。当最后一个移动命令是 "$" 时，整个可视列块将被扩展到每一行的行尾。这种状态在你使用垂直移动命令的时候一直被保持，直到你使用水平移动命令为止。就是说，用 "j" 命令会保持这种状态，而 "h" 会退出。


插 入 文 本

"I{string}<Esc>" 命令把 {string} 插到可视列块的每一行的左边。你用 CTRL-V 进入可视列块模式，然后移动光标定义一个列块。接着输入 I 进入插入模式，并随后输入文本。这时，你输入的内容只出现在第一行。
   然后你输入 <Esc> 结束输入，刚才输入的字符串将神奇地出现在每一行的可视区的左边。例如:

<B><FONT color="#3A6F2B">	include one </FONT></B>
<B><FONT color="#3A6F2B">	include two </FONT></B>
<B><FONT color="#3A6F2B">	include three </FONT></B>
<B><FONT color="#3A6F2B">	include four </FONT></B>

把光标移到第一行 "one" 的 "o"上，输入 CTRL-V。然后用 "3j" 向下移动到 "four"。现在你选中了四行的一个方块。接着输入:

<B>	Imain.&lt;Esc&gt;</B>

结果是:

<B><FONT color="#3A6F2B">	include main.one </FONT></B>
<B><FONT color="#3A6F2B">	include main.two </FONT></B>
<B><FONT color="#3A6F2B">	include main.three </FONT></B>
<B><FONT color="#3A6F2B">	include main.four </FONT></B>

如果选中的块经过一个短行，并且这行没有任何内容包括在可视列块中，则新的文本不会被插入到该行中。例如，对于下面的例子，用可视列块选中第一和第三行的 "long"，这样第二行的文本将不会被包括在可视列块中:

<B><FONT color="#3A6F2B">	This is a long line </FONT></B>
<B><FONT color="#3A6F2B">	short </FONT></B>
<B><FONT color="#3A6F2B">	Any other long line </FONT></B>

		  ^^^^ selected block

现在输入 "Ivery <esc>"。结果将是:

<B><FONT color="#3A6F2B">	This is a very long line </FONT></B>
<B><FONT color="#3A6F2B">	short </FONT></B>
<B><FONT color="#3A6F2B">	Any other very long line </FONT></B>

可以注意到，第二行中没有插入任何文本。

如果插入的文本中包括一个新行，则 "I" 命令的效果与普通插入语句一样，只影响块的第一行。

"A" 命令的效果与 "I" 命令一样，只是把文字插入可视列块的右边，而且在短行中会插 入文字。这样，你有在短行中插入文字与否的不同选择。
"A" 在如下情况会有一些特别: 选中一个可视列块然后用 "$" 命令使可视列块扩展 到行尾。然后用 "A" 命令插入文本，文件将被插入到 "每一行" 的行尾。 还是用上面的例子，在选中可视列块后输入 "$A XXX<Esc>"，结果将是:

<B><FONT color="#3A6F2B">	This is a long line XXX </FONT></B>
<B><FONT color="#3A6F2B">	short XXX </FONT></B>
<B><FONT color="#3A6F2B">	Any other long line XXX </FONT></B>

出现这个效果完全是 "$" 命令的作用，Vim 能记住这个命令，如果你用移动命令选中相同的可视列块，是不会有这样的效果的。


改变文本

可视列块中的 "c" 命令会删除整个可视列块并转入 "插入" 模式，使你可以开始文本，这些文本会被插入可视列块经过的每一行。在上面的例子中，如果仍选中包括所有 "long" 的一个可视列块，然后输入"c_LONG_<Esc>"，结果会变成:

<B><FONT color="#3A6F2B">	This is a _LONG_ line </FONT></B>
<B><FONT color="#3A6F2B">	short </FONT></B>
<B><FONT color="#3A6F2B">	Any other _LONG_ line </FONT></B>

与 "I" 命令一样，短行不会发生变化。而且在插入的过程中，你不能断行。

"C" 命令从块的左边界开始删除所有行的后半段，然后状态切换到 "插入" 模式让你输入文本。新的文本被插入到每一行的末尾。在上面的例子中，如果命令改为 "Cnew text<Esc>"，你将获得这样的结果:

<B><FONT color="#3A6F2B">	This is a new text </FONT></B>
<B><FONT color="#3A6F2B">	short </FONT></B>
<B><FONT color="#3A6F2B">	Any other new text </FONT></B>

可以注意到，尽管只有 "long" 被选中，它后面的内容也被删除了。所以在这种情况下，块的左边界才是有意义的。同样，没有包括在块中的行不会受影响。

还有一些命令只影响被选中的字符:

	~	交换大小写	(a <A HREF="eval.html#-&gt;">-&gt;</A> A and A <A HREF="eval.html#-&gt;">-&gt;</A> <A HREF="motion.html#a)">a)</A>
	<A HREF="undo.html#U">U</A>	变为<A HREF="change.html#uppercase">大写</A>  (a <A HREF="eval.html#-&gt;">-&gt;</A> A and A <A HREF="eval.html#-&gt;">-&gt;</A> A)
	<A HREF="undo.html#u">u</A>	变为<A HREF="change.html#lowercase">小写</A>  (a <A HREF="eval.html#-&gt;">-&gt;</A> a and A <A HREF="eval.html#-&gt;">-&gt;</A> <A HREF="motion.html#a)">a)</A>

以一个字符填充

要以某一个字符完全填充整个块，可以使用 "r" 命令。再次选中上例中的文本，然后键入 "rx":

<B><FONT color="#3A6F2B">	This is a xxxx line </FONT></B>
<B><FONT color="#3A6F2B">	short </FONT></B>
<B><FONT color="#3A6F2B">	Any other xxxx line </FONT></B>

备注:
        如果你要在可视列块中包括行尾之后的字符，请参考 25 章的 'virtualedit'
        特性。

平移

">" 命令把选中的文档向右移动一个 "平移单位"，中间用空白填充。平移的起始点是可视列块的左边界。
还是用上面的例子，">" 命令会导致如下结果:


<B><FONT color="#3A6F2B">	This is a	  long line </FONT></B>
<B><FONT color="#3A6F2B">	short </FONT></B>
<B><FONT color="#3A6F2B">	Any other	  long line </FONT></B>

平移的距离由 'shiftwidth' 选项定义。例如，要每次平移 4 个空格，可以用这个命令:

<B>	:set shiftwidth=4</B>

"<" 命令向左移动一个 "平移单位" ，但能移动的距离是有限的，因为它左边的不是空白 字符的字符会挡住它，这时它移到尽头就不再移动。


链接若干行

"J" 命令连接被选中的行。也就是删除所有的换行符。其实不只是换行符，行前后的多余空白字符会一起被删除而全部用一个空格取代。如果行尾刚好是句尾，就插入两个空格(参见 'joinspaces' 选项)还是用那个我们已经非常熟悉的例子，这回的结果将是:

<B><FONT color="#3A6F2B">	This is a long line short Any other long line </FONT></B>

"J" 命令其实不关心选中了哪些字符，只关心块涉及到哪些行。所以可视列块的效果与"v" 和 "V" 的效果是完全一样的。

如果你不想改变那些空白字符，可以使用 "gJ" 命令。

==============================================================================

*<A NAME="10.6"></A><B>10.6</B>*	读<A HREF="editing.html#writing">写</A>文件内容

当你在写一封 e-mail，你可能想包括另一个文件。这可以通过 ":read {filename}" 命令达到目的。这些文本将被插入到光标的下面。
    我们用下面的文本作试验:

<B><FONT color="#3A6F2B">	Hi John, </FONT></B>
<B><FONT color="#3A6F2B">	Here is the diff that fixes the bug: </FONT></B>
<B><FONT color="#3A6F2B">	Bye, Pierre. </FONT></B>

移动光标到第二行然后键入:

<B>	:read patch</B>

文件名为&quot;patch&quot;的内容会被插入 ，结果:

<B><FONT color="#3A6F2B">	Hi John, </FONT></B>
<B><FONT color="#3A6F2B">	Here is the diff that fixes the bug: </FONT></B>
<B><FONT color="#3A6F2B">	2c2 </FONT></B>
<B><FONT color="#3A6F2B">	&lt;	for (i = 0; i &lt;= length; ++i) </FONT></B>
<B><FONT color="#3A6F2B">	--- </FONT></B>
<B><FONT color="#3A6F2B">	&gt;	for (i = 0; i &lt; length; ++i) </FONT></B>
<B><FONT color="#3A6F2B">	Bye, Pierre. </FONT></B>

&quot;<A HREF="insert.html#:read">:read</A>&quot;命令可以接受范围. 文件将被插入到范围指定的最后一行的下面。所以":$r patch" 会把 "patch" 文件插入到当前文件的最后.
   如果要插入到文件的最前面怎么办？你可以把文本插入到第 0 行，这一行实际上是不存在的。在普通的命令的范围中如果你用这个行号会出错，但在 "read" 命令中就可以:

<B>	:0read patch</B>

这个命令把 "patch" 文件插入到全文的最前面.


保存部分行

要把一部分行写入到文件，可以使用 ":write" 命令。在没有指定范围的时候它写入全文，而指定范围的时候它只写入范围指定的行:

<B>	:.,$write tempo</B>

这个命令写入当前位置到文件末的全部行到文件 "tempo" 中。如果这个文件已经存在，你会被提示错误。Vim 不会让你直接写入到一个已存在的文件。如果你知道你在干什么而且确实想这样做，就加一个叹号:

<B>	:.,$write! tempo</B>

小 心: "!" 必须紧跟着 ":write"，中间不能留有空格。否则这将变成一个过滤器命令，这种命令我们在本章的后面会介绍.


添加内容到文件中

本章开始的时候介绍了怎样把文本添加到寄存器中。你可以对文件作同样的操作。例如，把当前行写入文件:

<B>	:.write collection</B>

然后移到下一个位置，输入:

<B>	:.write &gt;&gt;collection</B>

">>" 通知 Vim 把内容添加到文件 "collection" 的后面。你可以重复这个操作，直到获得全部你需要收集的文本.

==============================================================================

*<A NAME="10.7"></A><B>10.7</B>*	格式化文本

在你输入纯文本时，自动换行自然会是比较吸引的功能。要实现这个功能，可以设置'textwidth' 选项:

<B>	:set textwidth=78</B>

你可能还记得在示例 vimrc 文件中，这个命令被用于所有的文本文件。所以如果你使用的是那个配置文件，实际上你已经设置这个选项了。检查一下该选项的值:

<B>	:set textwidth</B>

现在每行达到 72 个字符就会自动换行。但如果你只是在行中间输入或者删除一些东西，这个功能就无效了。Vim 不会自动排版这些文本。要让 Vim 排版当前的段落:

<B>	gqap</B>

这个命令用 "gq" 开始，作为操作符，然后跟着 "ap"，作为文本对象，该对象表示 "一段" (a paragraph)。"一段" 与下一段的分割符是一个空行。

备注:
只包括空白字符的空白行不能分割 "一段"。这很不容易分辨。

除了用 "ap"，你还可以使用其它 "动作" 或者 "文本对象"。如果你的段落分割正确，你可以用下面命令排版整个文档:

<B>	gggqG</B>

"gg" 跳转到第一行，"gq" 是排版操作符，而 "G" 是跳转到文尾的 "动作" 命令。

如果你没有清楚地区分段落。你可以只排版你手动选中的行。先移到你要排版的行，执行"gqj"。这会排版当前行和下面一行。如果当前行太短，下面一行会补上来，否则多余的部分会移到下面一行。现在你可以用 "." 命令重复这个操作，直到排版完所有的文本。

==============================================================================

*<A NAME="10.8"></A><B>10.8</B>*	改变<A HREF="change.html#case">大小写</A>

你手头有一个分节标题全部是小写的。你想把全部 "section" 改成大写的。这可以用"gU" 操作符。先在第一列执行:

<B>			     gUw</B>
 	section header	    ----&gt;      SECTION header

&quot;<A HREF="change.html#gu">gu</A>&quot; <A HREF="motion.html#operator">操作符</A>正好相反:

<B>			     guw</B>
 	SECTION header	    ----&gt;      section header

你也能使用&quot;<A HREF="change.html#g~">g~</A>&quot;去转换<A HREF="change.html#case">大小写</A>. 所有这些命令都是操作符，所以它们可以用于 "动作"命令，文本对象和可视模式.
   要让一个操作符作用于当前行，可以执行这个操作符两次。例如，"d" 是删除操作符，所以删除一行就是 "dd"。相似地，"gugu" 使整一行变成小写。这可以缩成 "guu"。"gUgU" 可以缩成 "gUU" 而 "g~g~" 则是 "g~~"。例如:

<B>				g~~</B>
<B><FONT color="#3A6F2B"> 	Some GIRLS have Fun    ----&gt;   sOME girls HAVE fUN </FONT></B>

==============================================================================

*<A NAME="10.9"></A><B>10.9</B>*	使用扩展程序

Vim 有一套功能非常强大的命令，可以完成所有功能。但有些东西外部命令能够完成得更好或者更快。命令 "!{motion}{program}" 用一个外部程序对一个文本块进行过滤。换句话说，它用一个文本块作为输入，执行一个由 {program} 指定的外部命令，然后用该程序的输出替代选中的文本块。如果你不熟悉 UNIX 的过滤程序，上面的描述可以说是比较糟糕的。我们这里举个例子来说明一下。sort 命令能对一个文件排序。如果你执行下面的命令，未排序的文件input.txt 会被排序并写入 output.txt。(这在 UNIX 和 Microsoft Windows 上都有效)

<B>	sort &lt;input.txt &gt;output.txt</B>

现在在 Vim 中完成相同的功能。假设你要对 1 到 5 行排序。你可以先把光标定位在第一行，然后你执行下面的命令:

<B>	!5G</B>

"!" 告诉 Vim 你正在执行一个过滤操作。然后 Vim 编辑器等待一个 "动作" 命令来告诉它要过滤哪部分文本。"5G" 命令告诉 Vim 移到第 5 行。于是，Vim 知道要处理的是第1 行 (当前行) 到第 5 行间的内容。由于在执行一个过滤命令，光标被 Vim 移到了屏幕的底部，并显示一个 "!" 作提示符。现在你可以输入过滤程序的名字，在本例中就是 "sort" 了。因此，你整个命令将是:


<B>	!5Gsort&lt;Enter&gt;</B>

这个命令的结果是 sort 程序用前 5 行作为输入执行，程序的输出替换了原来的 5 行。

	line 55			      line 11
	line 33			      line 22
	line 11		--&gt;	      line 33
	line 22			      line 44
	line 44			      line 55
	last line		      last line

"!!" 命令用于对当前行执行过滤命令。在 Unix 上，"date" 命令能打印当前的时间和日期，所以，"!!date<Enter>" 用 "date" 的输出代替当前行。这在为文件加入时间戳的时候非常有用。


如 果 命 令 不 执 行 怎 么 办

启动一个外壳，发送一个命令并捕获它的输出，这需要 Vim 知道这个外壳程序是怎么工作的。如果你要使用过滤程序，你最好需要检查一下下面的选项:

   'shell' 指定 Vim 用于执行外部命令的外壳。
   'shellcmdflag' 传给外壳的参数
   'shellquote' 外壳程序使用的引号 (用于引用命令)
   'shellxquote' 用于命令和重定向文件名的引号
   'shelltype' 外壳程序的类型 (仅用于 Amiga)
   'shellslash' 在命令中使用正斜杠 (仅用于 MS-Windows 和相容系统)
   'shellredir' 用于把命令输出写入文件所使用的字符串

在 Unix 上，这几乎不是问题。因为总共只有两种外壳程序: "sh" 类的和 "csh" 类的。 Vim 会检查选项 'shell'，并根据它的类型自动设置这些参数。但在 MS-Windows 上，有很多不同的外壳程序，所以你必须修改这些外壳程序以便过滤功能正常执行。详细情况请参考相应选项的帮助。


读 入 一 个 命 令 的 输 出

要把当前目录的内容读进文件，可以用如下命令:
Unix 上:

<B>	:read !ls</B>
on MS-Windows:
<B>	:read !dir</B>

"ls" 或者 "dir" 的输出会被捕获并插入到光标下面。这好像读入一个文件一样，但是需要加上一个 "!" 让 Vim 知道后面是一个命令。这些命令还可以带参数。而且前面还可以带一个范围用于告诉 Vim 把这行放在什么地方:

<B>	:0read !date -u</B>

这将用 UTC 格式把当前的时间插入到文件开头。(当然了，你的 date 命令必须能够接受-u 选项。) 注意 这与 "!!date" 的区别: "!!date" 替代一行，而 ":read !date" 插入一行。


把 文 本 输 出 到 一 个 命 令

Unix 命令 "wc" 用于统计单词数目。要统计当前文件有多少个单词，可以这样:

<B>	:write !wc</B>

这和前面的写入命令一样，但文件名前面改为一个 "!" 用于告诉 Vim 后面是一个要被执行的外部命令。被写入的文本将作为指定命令的标准输入。这个输出将是:

<B><FONT color="#3A6F2B">       4      47     249 </FONT></B>

"wc" 命令惜字如金。这表示你有 4 行，47 个单词和 249 个字符。

注意不要错写成:

<B>	:write! wc</B>

这会强制把当前文件存到当前目录的 "wc" 文件中。在这里空格的位置是非常重要的！


重 画 屏 幕

如果外部程序产生一个错误信息，屏幕显示就会乱掉。Vim 颇重效率，所以它只刷新那些需要刷新的地方。可是它不可能知道其它程序修改了哪些地方。要强制 Vim 重画整个屏幕:

<B>	CTRL-L</B>

==============================================================================

下一章: |<A HREF="usr_11.html">usr_11.txt</A>|  从崩溃中恢复
<A HREF="#top">top</A> - <A HREF="index\.html">主帮助文件</A>
</PRE>
   </div>
</body>

</html>