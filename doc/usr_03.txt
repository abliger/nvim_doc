*usr_03.txt*	Nvim

		     VIM 用户手册 - by Bram Moolenaar
                                  译者: abliger      
			     移动


在你插入或者删除之前，你需要移动到合适的位置。Vim 有一大堆命令可以移动光标。本章向你介绍最重要的那些.你可以在|Q_lr|中找到这些命令的列表.

|03.1|	词移动
|03.2|	移动到行首或行尾
|03.3|	移动一个字符
|03.4|	括号匹配
|03.5|	移动到指定行
|03.6|	确认当前位置
|03.7|	滚动
|03.8|	简单搜索
|03.9|	简单搜索模式
|03.10|	使用标记

下一章: |usr_04.txt|  做小改动
上一章: |usr_02.txt|  Vim初步
目录:   |usr_toc.txt|
                                                               

==============================================================================
*03.1*	词移动

移动光标向前跳一个单词,使用 "w" 命令.像大多数 Vim 命令一样，你可以在命令前加数字前缀表示把这个命令重复多次.例如, "3w" 移动三个单词.下面的图形展现了它如何工作的(从 "x" 的位置开始):

	This is a line with example text ~
	  x-->-->->----------------->
	   w  w  w    3w

注意如果光标在单词的开始,"w" 会移动到下一个单词的开始."b" 命令移动到前一个单词的字首:

	This is a line with example text ~
	<----<--<-<---------<--x
	   b   b b    2b      b

也有 "e" 命令移动到下一个单词的字尾和"ge"命令移动到前一个单词的字尾:

	This is a line with example text ~
	   <----<----x---->------------>
	   2ge   ge     e       2e

如果你在一行的最后一个单词,使用 "w" 命令将会移动下一行第一个单词.因此你可以使用这个命令去移动段落,它比 "l" 快的多."b" 在反方向完成此功能.

一个单词以非单词字符结尾, 诸如 ".", "-" or ")".要改 变Vim 对于单词的判断, 查看 'iskeyword' 选项.如果你想直接在帮助中尝试它,'iskeyword' 需要重新设定，示例才能工作: >

	:set iskeyword&

尽可能使用空格分开单词.这不是通常意义的单词,这也是我们为什么使用大写.按字串移动的命令也全都是大写,像下图这样: 

	       ge      b	  w				e
	       <-     <-	 --->			       --->
	This is-a line, with special/separated/words (and some more). ~
	   <----- <-----	 -------------------->	       ----->
	     gE      B			 W			 E

组合使用小写和大写命令,你能在段落快速向前向后移动.

==============================================================================
*03.2*	移动到行首或行尾

"$" 命令移动光标到行尾.如果你的键盘有 <End> 键它将做相同的事.

"^" 命令移动到此行第一个非空字符处."0" 命令使光标移动到行首第一个字符和 <Home> 做了同样的事.  如下("." 代表空格):

		  ^
	     <-----------x
	.....This is a line with example text ~
	<----------------x   x-------------->
		0		   $

("....."这里表示空格)

像大多数移动命令,"$" 命令可以接受数量前缀.但是移动到一行的行尾 n 次没有什么意义.因此它会是光标移动到其他行e.例如,"1$" 移动到当前行的行尾，而 "2$" 则移动到下一行的行尾，如此类推.
"0" 命令不接受数量前缀,因为 "0" 已经是数字了.出人意料的是，使用数字到 "^" 没有反应.

==============================================================================
*03.3*	移动一个字符

最有用的移动命令是单字符查找命令.这个命令 "fx" 向前查找单字符x.提示: "f" 表示 "Find".
例如,你在下面例子的开始.假定你想要去 human 的 h.只使用 "fh" 光标将会定位到 h:


	To err is human.  To really foul up you need a computer. ~
	---------->--------------->
	    fh		 fy

你也能看到,"fy" 会移动到单词 really 的结尾.
你也可以添加数量修饰;所以你如果找 "foul" 的 "l" 可以使用 "3fl":


	To err is human.  To really foul up you need a computer. ~
		  --------------------->
			   3fl

"F"命令是向左查询:

	To err is human.  To really foul up you need a computer. ~
		  <---------------------
			    Fh

"tx" 命令很像 "fx" 命令,除了它只把光标移动到目标字符的前一个字符上.提示: "t" 代表 "To".这个命令的反向版本是 "Tx".

	To err is human.  To really foul up you need a computer. ~
		   <------------  ------------->
			Th		tn

这四个命令可以通过 ";" 重复."," 反向重复.无论用哪个命令，光标永远都不会移出当前行，哪怕这两行是连续的一个句子.

有时你启动了一个查找命令后才发现自己执行了一个错误的命令.如你键入了 "f" 之后意识到你想要键入 "F".想要打断查询，可以键入 <Esc>.所以 "f<Esc>" 是一个打断向前查找并不做任何事情.注意: <Esc> 能取消大部分操作，不只是查询.

==============================================================================
*03.4*	括号匹配

当你经常写程序会遇到嵌套的 () 结构.此时 "%" 命令是非常有用的: 它会移动到匹配的括号上.如果光标在一个 "(" 它将会移动匹配的 ")" 上.如果它在 ")" 它将移动到 "(" 上.

			    %
			 <----->
		if (a == (b * c) / d) ~
		   <---------------->
			    %

它也能在 [] 和 {} 上工作.(可用 'matchpairs' 选项定义.)

当光标不在有用的字符上时, "%" 将会向前查抄一个有用的字符.因此如果光标在例子的行首, "%" 会向前查找第一个 "(".然后它移动到匹配的字符上:

		if (a == (b * c) / d) ~
		---+---------------->
			   %

==============================================================================
*03.5*	移动到指定行

如果你是一个 C 或者 C++ 程序员，你对下面这样的错误信息非常熟悉:

	prog.c:33: j   undeclared (first use in this function) ~

它告诉你在33 行你需要进行修改一些东西.所以你要怎么去第 33 行? 一种方法是使用 "9999k" 回到文件头再使用 "32j" 向下移动 32 行.这不是一个好方法,但它可以工作.更好的方式是使用 "G" 命令. 使用数字,这个命令会让光标定位到你指定的行.例如, "33G" 把你带到 33 行.  (要用更好的方法在编译器的错误列表中移动,见 |usr_30.txt|, 的 :make 命令部分.)
如果没有计数前缀,"G" 会定位到文件尾.快速定位到文件首可以使用 "gg"."1G" 也会做相同的事,但却要打更多字符.

	    |	first line of a file   ^
	    |	text text text text    |
	    |	text text text text    |  gg
	7G  |	text text text text    |
	    |	text text text text
	    |	text text text text
	    V	text text text text    |
		text text text text    |  G
		text text text text    |
		last line of a file    V

另一个定位行的方法是使用带计数前缀的 "%" 命令.例如 "50%" 会移动到文件中间,"90%" 会移动到接近文件未的位置.

前面的描述假定你想移动到文件中的某一行，而不在乎它是否可见。那么如何移动到视野之内的一行呢？下图演示了三个可以使用的命令:

			+---------------------------+
		H -->	| text sample text	    |
			| sample text		    |
			| text sample text	    |
			| sample text		    |
		M -->	| text sample text	    |
			| sample text		    |
			| text sample text	    |
			| sample text		    |
		L -->	| text sample text	    |
			+---------------------------+

提示: "H" 代表 Home, "M" 代表 Middle 和 "L" 代表 Last.另外一种记法,"H" 代表 high, "M" 代表 Middle 和 "L" 代表 low.

==============================================================================
*03.6*	确认当前位置

如果查看你在文件的位置，有三种方法:

1.  使用 CTRL-G 命令.你可以获得下面的信息(假定 'ruler' 选项是 off):

	"usr_03.txt" line 233 of 650 --35%-- col 45-52 

    它显示了你编辑的文件名，光标所在的行号，总行数和光标再文件中行号占比.
    有时你能看到分开的行号.例如, "col 2-9".这表示光标处于第二个字符上，但由于使用了制表符，在屏幕上的位置是 9.

2.  设置 'number' 选项.这会再每一行前面显示行号: >

	:set number
 
<    要重新关闭这个选项: >

	:set nonumber
 
<    因为 'number' 是一个 boolean 选项, 关闭它既加上前缀 "no".boolean 选项只有两个值,on 或 off.
    Vim 有很多选项.  在 boolean 选项外还有数字选项和字符串选项.在用到的时候会给出一些例子的.

3.  设置 'ruler' 选项.  这会再Vim窗口的右下角显示当前光标的位置:

	:set ruler

使用 'ruler' 选项的好处是它不占多少地方,从而可以留下更多的地方给你的文本.

==============================================================================
*03.7*	滚动

CTRL-U 命令向下滚动半屏.想象一下通过窗口查看文本并且移动该窗口一般的高度.因此窗口移动到当前文字的上面，而文字则移到窗口的下面。不用担心记不住那边是上。很多人都是这样.
CTRL-D 命令把窗口命令把视窗向下移动半屏，所以把文字向上移动半屏.

				       +----------------+
				       | some text	|
				       | some text	|
				       | some text	|
	+---------------+	       | some text	|
	| some text	|  CTRL-U  --> |		|
	|		|	       | 123456		|
	| 123456	|	       +----------------+
	| 7890		|
	|		|	       +----------------+
	| example	|  CTRL-D -->  | 7890		|
	+---------------+	       |		|
				       | example	|
				       | example	|
				       | example	|
				       | example	|
				       +----------------+

每次滚动一行可以使用 CTRL-E (向上)和 CTRL-Y (向下).可以认为 CTRL-E 给了你额外的一行.  (如果你使用 MS-Windows 兼容的按键映射 CTRL-Y 会使用重做代替滚动.)

正向滚动整屏(减去两行)使用 CTRL-F.相反的使用 CTRL-B.应该很容易记住: F 代表 Forwards 和 B 代表 Backwards.

有一个问题是当向下移动很多行时在使用 "j" 你的光标是在屏幕的最下面.而你可能想要看到光标所在行的内容.这可以使用 "zz" 命令实现.

	+------------------+		 +------------------+
	| earlier text	   |		 | earlier text	    |
	| earlier text	   |		 | earlier text	    |
	| earlier text	   |		 | earlier text	    |
	| earlier text	   |   zz  -->	 | line with cursor |
	| earlier text	   |		 | later text	    |
	| earlier text	   |		 | later text	    |
	| line with cursor |		 | later text	    |
	+------------------+		 +------------------+

"zt" 命令把光标所在行放到顶部, "zb" 放在底部.有很多滚动命令, 见 |Q_sc|.要使一些行的内容总是保持在光标周围,使用 'scrolloff' 选项.

==============================================================================
*03.8*	简单搜索

搜索一个字符串,使用 "/string" 命令.例如,查找单词 include,使用命令:  >

	/include

你会注意到当你键入 "/" 时光标会想冒号命令一样跳转到Vim窗口的最后一行.那是你键入单词.你可以使用空格键(方向键和 <BS>)去更正错误.使用 <Left> 和 <Right> 当你需要的时候.使用 <Enter> 执行命令.

	注意:
	字符.*[]^%/\?~$ 有特殊含义.如果你想要在查找时找到它们，你必须使用 \ 符号在输入前转义它们。见下面.

使用 "n" 命令查找下一个匹配的字符串.使用下面的命令去发现光标后第一个 #include: >

	/#include

然后键入几次 "n".你会在之后的文本中找到每一个 #include.如果你知道匹配的次数可以在这个命令前面增加计数前缀.因此 "3n" 是第三个匹配的位置置.你也能在 "/" 前添加数量: "4/the" 会找到第四个匹配 "the" 的位置.

"?" 命令像 "/" 但是是反方向查找: >

	?word

"N" 命令反方向重复查找.因此在 "/" 命令后,使用 "n" 反方向查找,在 "?" 后使用 "N" 正向查找.

忽略大小写

通常，你需要正确的键入你想要查找的内容.如果你不关心单词的大写或者小写,可以查看 'ignorecase' 选项: >

	:set ignorecase

如果你想查找 "word", 它 也会匹配 "Word" 和 "WORD".如果要进行区分使用下面的命令: >

	:set noignorecase


历史

加入你做了三次查询: >

	/one
	/two
	/three

Now let's start searching by typing a simple "/" without pressing <Enter>.  If
you press <Up> (the cursor key), Vim puts "/three" on the command line.
Pressing <Enter> at this point searches for three.  If you do not press
<Enter>, but press <Up> instead, Vim changes the prompt to "/two".  Another
press of <Up> moves you to "/one".
   You can also use the <Down> cursor key to move through the history of
search commands in the other direction.

If you know what a previously used pattern starts with, and you want to use it
again, type that character before pressing <Up>.  With the previous example,
you can type "/o<Up>" and Vim will put "/one" on the command line.

The commands starting with ":" also have a history.  That allows you to recall
a previous command and execute it again.  These two histories are separate.


SEARCHING FOR A WORD IN THE TEXT

Suppose you see the word "TheLongFunctionName" in the text and you want to
find the next occurrence of it.  You could type "/TheLongFunctionName", but
that's a lot of typing.  And when you make a mistake Vim won't find it.
   There is an easier way: Position the cursor on the word and use the "*"
command.  Vim will grab the word under the cursor and use it as the search
string.
   The "#" command does the same in the other direction.  You can prepend a
count: "3*" searches for the third occurrence of the word under the cursor.


SEARCHING FOR WHOLE WORDS

If you type "/the" it will also match "there".  To only find words that end
in "the" use: >

	/the\>

The "\>" item is a special marker that only matches at the end of a word.
Similarly "\<" only matches at the beginning of a word.  Thus to search for
the word "the" only: >

	/\<the\>

This does not match "there" or "soothe".  Notice that the "*" and "#" commands
use these start-of-word and end-of-word markers to only find whole words (you
can use "g*" and "g#" to match partial words).


HIGHLIGHTING MATCHES

While editing a program you see a variable called "nr".  You want to check
where it's used.  You could move the cursor to "nr" and use the "*" command
and press "n" to go along all the matches.

Vim will highlight all matches. That is a very good way to see where the
variable is used, without the need to type commands.
   To switch this off: >

	:set nohlsearch

Then you need to switch it on again if you want to use it for the next search
command: >

	:set hlsearch

If you only want to remove the highlighting, use this command: >

	:nohlsearch

This doesn't reset the option.  Instead, it disables the highlighting.  As
soon as you execute a search command, the highlighting will be used again.
Also for the "n" and "N" commands.


TUNING SEARCHES

There are a few options that change how searching works.  These are the
essential ones:
>
	:set nowrapscan

This stops the search at the end of the file.  Or, when you are searching
backwards, it stops the search at the start of the file.  The 'wrapscan'
option is on by default, thus searching wraps around the end of the file.
>
	:set noincsearch

This disables the display of the matches while you are still typing your
search.


INTERMEZZO

If you like one of the options mentioned before, and set it each time you use
Vim, you can put the command in your Vim startup file.  Edit the file, for
example with: >

	:edit ~/.config/nvim/init.vim

Then add a line with the command to set the option, just like you typed it in
Vim.  Example: >

	Go:set hlsearch<Esc>

"G" moves to the end of the file.  "o" starts a new line, where you type the
":set" command.  You end insert mode with <Esc>.  Then write and close the
file: >

	ZZ

If you now start Vim again, the 'hlsearch' option will already be set.

==============================================================================
*03.9*	Simple search patterns

The Vim editor uses regular expressions to specify what to search for.
Regular expressions are an extremely powerful and compact way to specify a
search pattern.  Unfortunately, this power comes at a price, because regular
expressions are a bit tricky to specify.
   In this section we mention only a few essential ones.  More about search
patterns and commands can be found in chapter 27 |usr_27.txt|.  You can find
the full explanation here: |pattern|.


BEGINNING AND END OF A LINE

The ^ character matches the beginning of a line.  On an English-US keyboard
you find it above the 6.  The pattern "include" matches the word include
anywhere on the line.  But the pattern "^include" matches the word include
only if it is at the beginning of a line.
   The $ character matches the end of a line.  Therefore, "was$" matches the
word was only if it is at the end of a line.

Let's mark the places where "/the" matches in this example line with "x"s:

	the solder holding one of the chips melted and the ~
	xxx			  xxx		       xxx

Using "/the$" we find this match:

	the solder holding one of the chips melted and the ~
						       xxx

And with "/^the" we find this one:
	the solder holding one of the chips melted and the ~
	xxx

You can try searching with "/^the$"; it will only match a single line
consisting entirely of "the".  White space does matter here, thus if a line
contains a space after the word, like "the ", the pattern will not match.


MATCHING ANY SINGLE CHARACTER

The . (dot) character matches any existing character.  For example, the
pattern "c.m" matches a string whose first character is a c, whose second
character is anything, and whose third character is m.  Example:

	We use a computer that became the cummin winter. ~
		 xxx		 xxx	  xxx


MATCHING SPECIAL CHARACTERS

If you really want to match a dot, you must avoid its special meaning by
putting a backslash before it.
   If you search for "ter.", you will find these matches:

	We use a computer that became the cummin winter. ~
		      xxxx			    xxxx

Searching for "ter\." only finds the second match.

==============================================================================
*03.10*	Using marks

When you make a jump to a position with the "G" command, Vim remembers the
position from before this jump.  This position is called a mark.  To go back
where you came from, use this command: >

	``

This ` is a backtick or open single-quote character.
   If you use the same command a second time you will jump back again.  That's
because the "`" command is a jump itself, and the position from before this
jump is remembered.

Generally, every time you do a command that can move the cursor further than
within the same line, this is called a jump.  This includes the search
commands "/" and "n" (it doesn't matter how far away the match is).  But not
the character searches with "fx" and "tx" or the word movements "w" and "e".
   Also, "j" and "k" are not considered to be a jump, even when you use a
count to make them move the cursor quite a long way away.

The "``" command jumps back and forth, between two points.  The CTRL-O command
jumps to older positions (Hint: O for older).  CTRL-I then jumps back to newer
positions (Hint: for many common keyboard layouts, I is just next to O).
Consider this sequence of commands: >

	33G
	/^The
	CTRL-O

You first jump to line 33, then search for a line that starts with "The".
Then with CTRL-O you jump back to line 33.  Another CTRL-O takes you back to
where you started.  If you now use CTRL-I you jump to line 33 again.  And
to the match for "The" with another CTRL-I.


	     |	example text   ^	     |
	33G  |	example text   |  CTRL-O     | CTRL-I
	     |	example text   |	     |
	     V	line 33 text   ^	     V
	     |	example text   |	     |
       /^The |	example text   |  CTRL-O     | CTRL-I
	     V	There you are  |	     V
		example text

	Note:
	CTRL-I is the same as <Tab>.

The ":jumps" command gives a list of positions you jumped to.  The entry which
you used last is marked with a ">".


NAMED MARKS							*bookmark*

Vim enables you to place your own marks in the text.  The command "ma" marks
the place under the cursor as mark a.  You can place 26 marks (a through z) in
your text.  You can't see them, it's just a position that Vim remembers.
   To go to a mark, use the command `{mark}, where {mark} is the mark letter.
Thus to move to the a mark:
>
	`a

The command "'mark" (single quotation mark, or apostrophe) moves you to the
beginning of the line containing the mark.  This differs from the "`mark"
command, which also moves you to the marked column.

The marks can be very useful when working on two related parts in a file.
Suppose you have some text near the start of the file you need to look at,
while working on some text near the end of the file.
   Move to the text at the start and place the s (start) mark there: >

	ms

Then move to the text you want to work on and put the e (end) mark there: >

	me

Now you can move around, and when you want to look at the start of the file,
you use this to jump there: >

	's

Then you can use '' to jump back to where you were, or 'e to jump to the text
you were working on at the end.
   There is nothing special about using s for start and e for end, they are
just easy to remember.

You can use this command to get a list of marks: >

	:marks

You will notice a few special marks.  These include:

	'	The cursor position before doing a jump
	"	The cursor position when last editing the file
	[	Start of the last change
	]	End of the last change

==============================================================================

Next chapter: |usr_04.txt|  Making small changes

Copyright: see |manual-copyright|  vim:tw=78:ts=8:noet:ft=help:norl:
